---
layout: manual
title: Insert, Update and Delete
headtitle: Insert, Update and Delete - 
---

h2. Insert 

The insert mechanism is the least surprising of all : 

{% highlight scala %}

    val herbyHancock = 
	  artists.insert(new Artist("Herby Hancock"))
	  
    val ponchoSanchez = 
	  artists.insert(new Artist("Poncho Sanchez"))
	  
    val theMeters = 
	  artists.insert(new Artist("The Meters"))	
{% endhighlight %}

Objects that extend KeyedEntity[K] where K is a numeric type
will have their id field assigned their newly created primary key
value (the mechanism for generating keys is specific to each DatabaseAdaptor).

h2. Update 

There are two forms of updates :

1. Full

{% highlight scala %}

  watermelonMan.title = "The Watermelon Man"
  watermelonMan.year = watermelonMan.year + 1  
  songs.update(watermelonMan)
{% endhighlight %}


2. Partial :

{% highlight scala %}

    update(songs)(s =>
      where(s.title === "Watermelon Man")
      set(s.title := "The Watermelon Man",
          s.year  := s.year.~ + 1)
    )	
{% endhighlight %}

(The explanation for the '~' in s.year.~ is "here":./getting-started.html#disambiguate)

The SQL will be : 

{% highlight sql %}
  update Song set
    title = ?,
    year = (year + ?)
  Where
    (title = ?)
{% endhighlight %}


h2. Delete

Delete is done either by key (when objects extend KeyedEntity[K]), or
with a boolean clause via the table's deleteWhere method, 
example of Table[PlaylistElement].deleteWhere usage :

{% highlight scala %}

  def removeSong(song: Song) =
    playlistElements.deleteWere(ple => ple.songId === song.id)

  def removeSongOfArtist(artist: Artist) =
    playlistElements.deleteWere(ple =>
      (ple.playlistId === id) and
      (ple.songId in from(songsOf(artist.id))(s => select(s.id)))
    )

{% endhighlight %}


h2. Batched updates and Inserts


org.squeryl.Table[A] has insert and update methods that take an Iterable[A]. Invoking them does the update in a single roundtrip to the database via JDBC's batched update functionality. 

The advantage of this is obviously making 1 trip to the DB versus N trips (given an iterable with N elements).

{% highlight scala %}

    addresses.insert(List(
      new Address("St-Dominique",14, None,None,None),
      new Address("St-Urbain",23, None,None,None),
      new Address("Sherbrooke",1123, None,Some(454),Some("B"))
    ))

    addresses.insert(List(
      new Address("Van Horne",14, None,None,None)
    ))


    val q = addresses.where(a => a.streetName in streetNames)

    assertEquals(4, q.Count : Long, "batched update test failed")
    
    // The update here is one in a single DB trip :
    
    addresses.update(q.map(a =>{a.streetName += "Z"; a}))

    val updatedStreetNames = List("Van HorneZ", "SherbrookeZ", "St-UrbainZ", "St-DominiqueZ")

    val updatedQ = addresses.where(a => a.streetName in updatedStreetNames)

 
{% endhighlight %}
    
