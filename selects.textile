---
layout: manual
title: Select
headtitle: Select - 
---

h2. The variations on Select

Select statements return an immutable Query[T] that
is itself a Queryable[T] and a lazy Iterable[T].

{% highlight scala %}
 
class Artist(val id: Long, val name:String)  {
   
  def songs = 
    from(MusicDb.songs)(s => where(s.artistId === id) select(s))

}
{% endhighlight %}

The laziness here means that the query is sent to the database only
when starting iteration, or in other words, when Iterable.iterator is called.

The select function takes any legal Scala expression whose
type determines the generic parameter of the <notextile>Query[R]</notextile>

{% highlight scala %}
  def select[R](r: =>R): R
{% endhighlight %}

The select expression will be evaluated for every row returned by the query.

It is also possible to select with alternative (shorter but less generic) syntax :

{% highlight scala %}
class Song(var title: String, var artistId: Long) extends KeyedEntity {
   
  import MusicDb._ // the schema can be imported in the scope
  
  // A shorter syntax for single table queries :
  def artist = artists.where(a => a.id === artistId).single
 
  // lookup by key is available because Artist extends 
  // KeyedEntity[Long] : 
  def lookupArtist = artists.lookup(artistId)
}
{% endhighlight %}

Note that the .lookup[K](k: K) i.e. lookup by key method on a Table[T] is only 
available for Table[T] that are of the form : Table[KeyedEntity[K]]

The classes Artist and Song in this example are part of a one to many relation
that can be accessed via the methods.

h2. Nesting Sub Queries

For the next examples, the following query will be nested as an inner query 
into other queries :

{% highlight scala %}
  def songsInPlaylistOrder =
    from(playlistElements, songs)((ple, s) =>
      where(ple.playlistId === id and ple.songId === s.id)
      select(s)
      orderBy(ple.songNumber asc)
    )
{% endhighlight %}

h3. Sub Queries in the From clause :

The from clause takes Queryable[T]'s, a trait of Table[T] View[T] *and* Query[T].
Notice the Query[Song] *funkAndLatinJazz.songsInPlaylistOrder* in the from clause :
 
{% highlight scala %}

    val songsFromThe60sInFunkAndLatinJazzPlaylist2 =
      from(funkAndLatinJazz.songsInPlaylistOrder)(s=>
        where(s.id === 123)
        select(s)
      )
{% endhighlight %}

h3. Sub Queries in the Where clause :

Joins can also be nested in the where clause just like in SQL :

{% highlight scala %}
    val songsFromThe60sInFunkAndLatinJazzPlaylist =
      from(songs)(s=>
        where(s.id in 
		  from(funkAndLatinJazz.songsInPlaylistOrder)
          (s2 => select(s2.id))
		)
        select(s)
      )

    for(s <- songsFromThe60sInFunkAndLatinJazzPlaylist)
      println(s.title + " : " + s.year)
{% endhighlight %}

 The SQL generated for the above statement is :

{% highlight sql %}
Select
  Song1.year as Song1_year,
  Song1.title as Song1_title,
  Song1.filePath as Song1_filePath,
  Song1.artistId as Song1_artistId,
  Song1.id as Song1_id
From
  Song Song1
Where
 (Song1.id in 
  (Select
     q3.Song5_id as q3_Song5_id
   From
     (Select
        Song5.year as Song5_year,
        Song5.title as Song5_title,
        Song5.filePath as Song5_filePath,
        Song5.artistId as Song5_artistId,
        Song5.id as Song5_id
      From
        PlaylistElement PlaylistElement4,
        Song Song5
      Where
        ((PlaylistElement4.playlistId = ?) and (PlaylistElement4.songId = Song5.id))
      Order By
        PlaylistElement4.songNumber Asc
      )  q3   
  ))

{% endhighlight %}

Doing a 3 level nested join is by no means necessary and serves
no other purposes than demonstration.

h2. Select Distinct

Calling the *.distinct* method on a Query[] creates a copy of it that has a 'distinct' select clause :
 
{% highlight scala %}
  from(songs)(s => select(&(s.title))).distinct
{% endhighlight %}

h2. For Update

Calling the *.forUpdate* method on a Query[] creates a copy of it that has a 'forUpdate' locking directive :
 
{% highlight scala %}
  aTable.where(t => t.aField === aValue).forUpdate
{% endhighlight %}
